var Q = require('q');
var btoa = require('btoa');

// ## TaggedAPI Constructor
//
// Creates a new Tagged API client that is bound to the request's cookies.
// Each full page request by the user should create a new instance of the API
// client to ensure that the calls are made on behalf of the user.
//
// **Params:**
//
//     endpoint: [string] URL to post API calls to.
//     options: [object|null] Common options that are used with each API call.
//     http: [HttpAdapter] Adapter to make HTTP requests.
var TaggedAPI = function(endpoint, options, http) {
    this._endpoint = endpoint;
    this._http = http;

    // API calls that are made within a single JS execution frame will be added
    // to the queue and processed as a whole on the next tick.
    this._queue = [];

    // This timeout is used to trigger the HTTP request on the next tick. All
    // API calls that are added to the queue will be batched together.
    this._batchTimeout = null;

    // Common parameters that will be passed with each API call are stored here.
    this._options = mergeRecursive({
        // These parameters are appended to the endpoint as a query string.
        query: {},

        // Parameters registered here will be merged with parameters that are
        // passed in to the `execute()` call.
        params: {
            // Track is autogenerated per API instance, allowing the API server
            // to know which API calls are made within a single requst.
            track: this._generateTrackId()
        },

        // The user's cookies are required by the API to properly handle the request.
        cookies: ''
    }, options || {});
};

// Generates a random track ID.
TaggedAPI.prototype._generateTrackId = function() {
    return btoa(Math.random() * (100000000)).substr(0, 10);
};

// Executes an API call with given method and params. Returns a promise that
// is resolved with the API call's response data, or rejected if the API response
// cannot be parsed as JSON. Additionally, if the result contains a `stat` property
// that does not equal `ok`, then the promise will be rejected.
TaggedAPI.prototype.execute = function(method, params) {
    if (!method || typeof method !== "string") {
        throw new Error("Method is required to execute API calls");
    }

    var deferred = Q.defer();

    this._queue.push({
        method: method,
        params: mergeRecursive(this._options.params, params || {}),
        deferred: deferred
    });

    if (null === this._batchTimeout) {
        this._batchTimeout = setTimeout(this._postToApi.bind(this), 1);
    }

    return deferred.promise;
};

TaggedAPI.prototype._postToApi = function() {
    var body = stringifyQueue(this._queue);
    var queryArray = [],
        queryString;

    for(var key in this._options.query) {
        queryArray.push(key + "=" + this._options.query[key]);
    }

    queryString = queryArray.join('&');

    this._http.post({
        body: body,
        url: this._endpoint + "?" + queryString,
        cookies: this._options.cookies
    })
    .then(parseResponseBody)
    .then(resolveQueue.bind(this, this._queue))
    .catch(rejectQueue.bind(this, this._queue))
    .done();

    this.resetQueue();
};

// Parses the body of a JSON response and returns an
// array of objects.
var parseResponseBody = function(response) {
    var results = [];
    var responses = JSON.parse(response.body);

    // exceptions will be bubbled up
    for (var i in responses) {
        results.push(JSON.parse(responses[i]));
    }

    return results;
};


// Resolves all queued promises with the associated
// result from the API response.
var resolveQueue = function(queue, results) {
    for (var i in queue) {
        var result = results[i];
        if (result.stat && result.stat !== 'ok') {
            queue[i].deferred.reject(result.stat);
        } else {
            queue[i].deferred.resolve(result);
        }
    }

    return results;
};

// Rejects all the queued promises with the provided
// error.
var rejectQueue = function(queue, error) {
    for (var i in queue) {
        queue[i].deferred.reject(error);
    }

    return error;
};

// Clears the queue of API calls and the batch timeout.
TaggedAPI.prototype.resetQueue = function() {
    if (null !== this._batchTimeout) {
        clearTimeout(this._batchTimeout);
        this._batchTimeout = null;
    }
    this._queue = [];
};

TaggedAPI.middleware = function(url, options) {
    var NodeAdapter = require('./http_adapter/node');
    var http = new NodeAdapter();

    return function(req, res, next) {
        req.api = new TaggedAPI(url, mergeRecursive({
            cookies: req.headers && req.headers.Cookie
        }, options || {}), http);
        next();
    };
};

// Transforms the post data into the format required by the API
var stringifyQueue = function(queue) {
    // Each API call will be transformed into a string of
    // key/value pairs and placed into this array.
    var calls = [];

    for (var i in queue) {
        var call = stringifyCall(queue[i]);
        calls.push(call);
    }

    return "\n" + calls.join("\n") + "\n";
};

var stringifyCall = function(call) {
    // Each key/value pair of the API call will be placed
    // into this params array as a `key=value` string.
    var params = ["method=" + encodeURIComponent(call.method)];

    // Add each custom param to the params array as a
    // `key=value` string.
    for (var key in call.params) {
        // Passing `null` as a value is not supported by
        // the API, so omit those values.

        //TODO: support arrays as values
        if (null !== call.params[key] && call.params.hasOwnProperty(key)) {
            params.push(
                // Keys and values must be encoded to
                // prevent accidental breakage of string
                // splits by `=` and `&`.
                encodeURIComponent(key) +
                "=" +
                encodeURIComponent(call.params[key])
            );
        }
    }

    // All params are joined by `&`, resulting in a single
    // one-line string to represent the API call.
    return params.join('&');
};

// Recursively merge properties of two objects
// Adapted from http://stackoverflow.com/a/383245/249394
function mergeRecursive(obj1, obj2) {
    for (var p in obj2) {
        if (!obj2.hasOwnProperty(p)) {
            continue;
        }

        try {
            // Property in destination object set; update its value.
            if (obj2[p].constructor === Object) {
                obj1[p] = mergeRecursive(obj1[p], obj2[p]);
            } else {
                obj1[p] = obj2[p];
            }
        } catch(e) {
            // Property in destination object not set; create it and set its value.
            obj1[p] = obj2[p];
        }
    }

    return obj1;
}

module.exports = TaggedAPI;
